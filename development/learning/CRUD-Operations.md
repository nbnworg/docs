# Introduction To AWS Amplify

AWS Amplify is  a set of tools and services that help developers build, connect, and host fullstack web and mobile applications on AWS. It includes:
 - Amplify Framework: A collection of SDKs, libraries, tools, and documentation for client app development
 - Amplify Hosting: A fully managed service for deploying and hosting web applications, with built-in CI/CD workflows
 
In short AWS Amplify is like a friendly assistant for building and managing web and mobile apps. It provides tools, pre-built components, and cloud services to help you create powerful apps quickly and easily, even if youâ€™re not a tech expert.

![enter image description here](https://miro.medium.com/v2/resize:fit:1400/1*3BXVzT6b5D_8Bwb_yLJwXg.png)

# Configure REST API
The REST API composed of one or more than one paths, these paths will use the lambda function to handle the request received by them and provide reponse corresponding to the request. Amplify CLI creates a single resource in Amazon API Gateway so you can handle all routes, HTTP Methods and paths, with a single Lambda function via a Lambda Proxy integration.

## Create REST API

Navigate to the root of the project and run:

    amplify init
 
After wizard completes it process run the next command that will define you API

    amplify add api
    
Once you execute the above command it will ask you follow-up questions, answer them accordingly how you want your API to be setup

Whenever you wan to deploy you new API you will use below command for it. It is also used when you want to push the changes of your lambda function from local system to aws so that your api work accordingly

    amplify push
    

## Read/Fetch Data

Whenever you need to fetch the data from the database and display that to the user that means you need to invoke an endpoint which is defined for this purpose. The request generated by the amplify will invoke the endpoint that is defined in API Gateway and this API Gateway is linked with the lambda function so what happens is that the request sent by the user is first received by the api gateway it checks whether the particular endpoint is defined or not if it is defined it execute the particular lamda function written for it and if not then it throws error.

Below is a simple example how you can handle fetch data request

    const response = (await retrievAuthorDetails(authorname)) as {result:  any};
    
"retrieveAuthorDetails" is a function responsible to invoke the endpoint defined for it. It will consist of apiName,  path, options where the apiName is the name of your api that you have created, path will be the further location you want to go after coming onto this api. The api will consist of several paths attached to it and the last is the options where you define your queryType and the parameters that you need to pass from here to the lambda function

Below is the function defination of retrievAuthorDetails

    import { get } from  "aws-amplify/api";
    
    export const retrievAuthorDetails = async (authorname: string): Promise<Author |unknown> =>{
    
    try {
    
    const  response  =  await  get({
    apiName: BASE_API, //Here will be your API name that you have defined while creating your API
    path: API_PATHS.AUTHOR, //Here will be your endpoint that you will invoke from API
    options: {
    queryParams: {
	    queryType: "author",
	    authorname: authorname,
	    },
    },
    }).response;
  
    console.log(response);
    
    return  response.body.json().then((data) => {
    return  data;
    });
    
    } catch (error) {
    
    console.error("Error retrieving author details:", error); 
    throw  error;
    }};

Now as you have written amplify function in the frontend for read or fetch the details there should be corresponding lambda function also that need to be executed as the main functionality or the process how things will be carried out will be defined into that.
For that first we  need to define a `GET` function which will take dynamodb and event as parameters and in the defination of that function first we will extract the querytype that we have passed in the queryparams of the particular amplify function.
As next step we will execute the main lambda function equivalent to the querytype and that's the only reason that we have passed the querytype in our amplify function.
Below is the lambda function for the read operations

    const { QueryCommand } =  require("@aws-sdk/lib-dynamodb");
    async  function  authorDetails(dynamodb, event) {
    
	    const  authorname  =  event.authorname;
	    const  query_params  = {
		    TableName: AUTHORTable,
		    KeyConditionExpression: "id = :authorname",
		    ExpressionAttributeValues: {
			    ":authorname": authorname,
		    },
	    };
	    const  data  =  await  dynamodb.send(new  QueryCommand(query_params));
	    return  data.Items;
    }
    
As we can see in the above lambda function we have used `QueryCommand` and The `QueryCommand` of DynamoDB is used when you need to retrieve multiple items from a table based on a primary key value or a composite primary key (partition key and sort key). It allows for efficient querying of items that match specific criteria, especially when you need to retrieve a range of items that share the same partition key.


## Update Data

To update the data, we need to invoke a specific Lambda function. This is done using the Amplify framework, which makes a call to API Gateway. The API Gateway is linked to the Lambda function, triggering it to execute its functionality and return a response.
Below is the example of how to write put request for sending an update request.

    export  const  updateVoteForNews  =  async (
    articleid:  string,
    voteType:  string,
    previousVoteType:  string
    ):  Promise<Post[] |  unknown> => {
    try {
    
    const  response  =  await  put({
	    apiName: BASE_API,
	    path: API_PATHS.NEWS,
	    options: {
	    queryParams: {
		    id: articleid,
		    queryType: voteType,
		    previousVoteType: previousVoteType,
		    },
	    },
    });
    
    return  response;
    } catch (error) {
    
	    console.error("Due to some reasons your vote cannot be counted");
	    throw  error;
    }
    };

In the above stated example we are generating a put request to the api defined inside apiName to a particular route defined inside path which consist of defined query parameter. It will have querytype which is compulsory to pass and articleid, previousvotetype will be the parameter that will be passed to the lambda function.

Now as you have written amplify function in the frontend for update the details there should be corresponding lambda function also that need to be executed as the main functionality or the process how things will be carried out will be defined into that.
For that first we  need to define a `PUT` function which will take dynamodb and event as parameters and in the defination of that function first we will extract the querytype that we have passed in the queryparams of the particular amplify function.
As next step we will execute the main lambda function equivalent to the querytype and that's the only reason that we have passed the querytype in our amplify function.
Below is the lambda function for the update operations

    const { UpdateCommand } =  require("@aws-sdk/lib-dynamodb");
    async  function  updateVoteOnNews(dynamodb, event) {
    
	    const  articleid  =  event["id"];
	    const  votetype  =  event.queryType;
	    const  previousvotetype  =  event.previousVoteType;
	    let  updateExpression, expressionAttributeValues;
    
	    try {
	    if (votetype  ===  "upvote"  &&  previousvotetype  ===  "upvote") {
	    
		    (updateExpression  =  "set upvote = upvote - :inc"),
		    (expressionAttributeValues  = { ":inc": 1 });
	    
	    } else  if (votetype  ===  "downvote"  &&  previousvotetype  ===  "downvote") {
    
		    (updateExpression  =  "set downvote = downvote - :inc"),
		    (expressionAttributeValues  = { ":inc": 1 });
	    
	    } else  if (votetype  ===  "upvote"  &&  previousvotetype  ===  "downvote") {
	    
		    (updateExpression  = "set upvote = upvote + :inc, downvote = downvote - :dec"),
		    (expressionAttributeValues  = { ":inc": 1, ":dec": 1 });
	    
	    } else  if (votetype  ===  "downvote"  &&  previousvotetype  ===  "upvote") {
	    
		    (updateExpression  ="set downvote = downvote + :inc, upvote = upvote - :dec"),
		    (expressionAttributeValues  = { ":inc": 1, ":dec": 1 });
	    
	    } else  if (votetype  ===  "upvote") {
	    
		    (updateExpression  =  "set upvote = if_not_exists(upvote, :start) + :inc");
		    (expressionAttributeValues  = { ":inc": 1, ":start": 0 });
	    
	    } else  if (votetype  ===  "downvote") {
	    
		    (updateExpression  ="set downvote = if_not_exists(downvote, :start) + :inc");
		    (expressionAttributeValues  = { ":inc": 1, ":start": 0 });
		    
	    }
	    } 
	    catch (error) {
		    console.error(error);    
		    return { status: "error", error: error.message };    
	    }
	    
	    const  updateParams  = {
		    TableName: NBNWTableName,    
		    Key: { id: articleid },    
		    UpdateExpression: updateExpression,
		    ExpressionAttributeValues: expressionAttributeValues,
	    };
	    const  data  =  await  dynamodb.send(new  UpdateCommand(updateParams));
	    return  data.Items;,
    }

As we can see in the above lambda function we have used `UpdateCommand`. The `UpdateCommand` in DynamoDB is used to modify an existing item's attributes or to add new attributes to an item. This command is efficient for updating single items based on their primary key.

## Delete Data

To initiate a request of deleting an item from database we need to write its amplify function pointing to the api and the specific route from where it will delete. It also consist of query parameters which have querytype and the id from where it have to delete.
Below is the example of an amplify function written to delete title from an article id

    export  async  function  deleteTitleForId(
    titleid:  string
    ):  Promise<Title  |  unknown> {
    try {
    
    const  response  =  await  del({
    apiName: BASEAPI,
    path: ApiPath.TITLE,
    options: {
    queryParams: {
	    queryType: TitleQueryType.ID,
	    id: titleid,
	    },
    },
    }).response;
    
    return  response;
    } catch (error) {
    
    console.error('Error deleting title:', error);
    throw  error;
	    }
    }
 
In the above stated example we are generating the delete request to a specific mentined api at a particular specific route.

Now as you have written amplify function in the frontend for delete the details there should be corresponding lambda function also that need to be executed as the main functionality or the process how things will be carried out will be defined into that.
For that first we  need to define a `DELETE` function which will take dynamodb and event as parameters and in the defination of that function first we will extract the querytype that we have passed in the queryparams of the particular amplify function.
As next step we will execute the main lambda function equivalent to the querytype and that's the only reason that we have passed the querytype in our amplify function.
Below is the lambda function for the delete operations
    
    const { DeleteCommand } =  require('@aws-sdk/lib-dynamodb');
    async  function  deleteTitleById(dynamodb, event) {
    
	    const  titleId  =  event['id'];
	    const  delete_params  = {
		    TableName: process.env.STORAGE_PENDINGTITLES_NAME,
		    Key: {'id': titleId},
	    };
    const  data  =  await  dynamodb.send(new  DeleteCommand(delete_params));
    return  data.Items;
    }
   
As we can see in the above lambda function we have used `DeleteCommand`. The `DeleteCommand` in DynamoDB is used to remove an item from a table based on its primary key.
